

\documentclass{article}


% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2023


% ready for submission
\usepackage[preprint]{neurips_2023}


% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
%     \usepackage[preprint]{neurips_2023}


% to compile a camera-ready version, add the [final] option, e.g.:
%     \usepackage[final]{neurips_2023}


% to avoid loading the natbib package, add option nonatbib:
%    \usepackage[nonatbib]{neurips_2023}


\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{amsmath,amssymb}
\usepackage{listings,graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\title{Report for Programming Assignment 3 (Sudoku)}


% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to LaTeX to determine where to break the
% lines. Using \AND forces a line break at that point. So, if LaTeX puts 3 of 4
% authors names on the first line, and the last on the second line, try using
% \AND instead of \And before the third author name.


\author{%
  Matthew Callahan\\
  \And
  Suphalerk Lortaraprasert
  % examples of more authors
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \AND
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
}


\begin{document}


\maketitle


\begin{abstract}
  We solved the problem of SuDoKu with backtracking search. We used both simple backtracking search and various levels of inference procedures based on increasingly complicated models of the problem. We found that increasing the complexity of the models decreased the amount of backtracking required to solve various problems. 
 \end{abstract}

\section{Introduction}
SuDoKu is a challenge problem, being both a puzzle and a constraint satisfaction problem. In this game, each unit (rows, columns, and boxes) must adhere to the "all-diff" constraint, meaning every digit within a unit must be unique. The 81 squares on the SuDoKu grid are akin to variables, each with a domain from 1 to 9. Depending on the problem, various cells will also be forced to certain values. 

We implemented backtracking linesearch with several different levels of inference from the dynamics of the problems. 

  
\section{Environment Descriptions}
\subsection{The board}
the board is a nine by nine grid with each row, column, and sub-three-by-three grid maintaining its own all-diff constraint. We implemented thiss with an array of sets in python. When an element was assigned to a cell, we removed that value from all the relavent neighbors. 
\subsection{Constraint propagation}
In the constraint propagation step, the SuDoKu board undergoes a series of rule applications in the following order. This process aims to systematically decrease the domain values associated with each variable:
\begin{description}
  \item[Rule 1:] If a cell has only one value remaining in its domain, assign that value to the cell.
  \item[Rule 2:] If a value x is not present in the domain of any other cell within the same row, column, or box as a particular cell, assign x to that cell.
  \item[Rule 3:] Identify k squares within any row, column, or box, where each square shares a domain containing the same k numbers or a subset of those numbers. Then, eliminate those k numbers from the domains of all other cells within that unit. This is referred to as the "naked double" and "naked triple" rule when k=2 and k=3, respectively.
\end{description}


\label{alg:Constraint Propagation}
 
 
 
   
   
 
 

\subsection{Backtracking Search}
  
\label{alg:Backtracking Search}
 

\section{Experimental setup}
\subsection{Fixed  Baseline}

\subsection{Most Constrained Variable}

\section{Results}
 \subsection{Backtracking}
\subsection{Runtime Performance}
\begin{table}[h]\centering
  \begin{tabular}{lll}
    \toprule
    puzzle number& Arbitrary Order Backtracks & Most Constrained Variable Backtracks\\
    \midrule
    1& 5 & 0\\
    \midrule
    6& 13&0\\
    \midrule
    7& 10&0\\
    \midrule
    20&10&0\\
    \midrule
    30& 8&0\\
    \midrule
    41& 12& 0\\
    \midrule
    42& 6& 0\\
    \midrule
    43& 13&0\\
    \midrule
    44&9&0\\
    \midrule
    50&6&0\\
    \midrule
    55 &11 &0\\
    \midrule
    61& 11 &0\\
    \midrule
    62 &5&0\\
    \midrule
    67&7&0\\
    \midrule
    68& 5&0\\
    \midrule
    69&7&0\\
    \midrule
    70& 12 &1\\
    \bottomrule
  \end{tabular}
  \caption{Number of backtracks for various algorithms for the easy puzzles. These algorithms did not use any of the inference rules besides forward checking. }
  \label{tab:resultsEasy}
\end{table}
\section{Discussion}
% Answer the remaining questions not answered in earlier sections



  
\end{document}