\documentclass{article}


% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2023


% ready for submission
\usepackage[preprint]{neurips_2023}


% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
%     \usepackage[preprint]{neurips_2023}


% to compile a camera-ready version, add the [final] option, e.g.:
%     \usepackage[final]{neurips_2023}


% to avoid loading the natbib package, add option nonatbib:
%    \usepackage[nonatbib]{neurips_2023}


\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{amsmath,amssymb}
\usepackage{listings,graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\title{Report for Programming Assignment 2 (Fifteen Puzzle)}


% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to LaTeX to determine where to break the
% lines. Using \AND forces a line break at that point. So, if LaTeX puts 3 of 4
% authors names on the first line, and the last on the second line, try using
% \AND instead of \And before the third author name.


\author{%
  Matthew Callahan\\
  \And
  Suphalerk Lortaraprasert
  % examples of more authors
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \AND
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
}


\begin{document}


\maketitle


\begin{abstract}
 We consider the performance of two algorithms, A* search and rbfs, on finding solutions to a generic fifteen puzzle. We compared their performance with respect to computation time and optimality of solution for various levels of scrambling of the board and with respect to two different heuristics. 
\end{abstract}

\section{Introduction}

In this paper, we examine the performance of two search algorithms, Compassion A* and RBFS, using a 4x4 puzzle as a representation. The environment is randomized to ensure optimal exploration. To enhance efficiency, we introduce a random algorithm designed to avoid repeating the same steps.

\section{Environment Descriptions}
We consider the setting of the fifteen puzzle. In this setting, a four by four grid contains fifteen(15) tiles, where the tiles can be slid to move the empty square around. The tiles are each numbered and the goal of the program is to find a sequence of moves that will return the tiles to their correct order after being scrambled in the minimum moves with the minimum amount of calculation time. 

\subsection{Heuristic function}
We used the Manhattan distance as one of our heuristics. For this, we considered each tile to have a target location, and counted the total number of squares each tile must be moved to reach that location. This is equivalent to assuming each tile can be moved through other tiles.

We also used a heuristic suggested by Michael Kim, on his blog at https://michael.kim/blog/puzzle, where the Manhattan distance is augmented by an addition of two moves for each location that has two tiles next to each other that need to be directly swapped. This is because it takes at least three moves to swap two tiles. This is no longer an admissible heuristic because it assumes that each swap must happen independently. 

This is not quite the same as what is reccomended by Mr. Kim, since he does not mention anythin about what to do with vertical swaps. We treated vertical swaps differently because the correct offset between vertical tiles is 4 instead of 1. 

\subsection{A* search}
We implement the A* search algorithm for finding the paths between initial states to a given goal state in the problem of puzzle 4x4. It is a variant of the uniform cost search by using a heuristic function for each node in addition to path costs.
\begin{algorithm}[h]
  
  \caption{Programmatic Description of A$^*$ search}
   
    \State {openlist = [Node(nodeState, 0, nodeState.manhdist())] // Start with the initial state}
    \State {closedlist = []}
    \State {totalHeuristic = 0  // keep running total of heuristic time}
    \While  {openlist  is not empty:}
    \State {currentnode = node with minimum fscore in openlist}
        
    \State {currentnode.state.checkcanmove()}
    
    \State {remove currentnode from openlist}
    \State {add currentnode to closedlist}
    \If { currentnode.heuristic is 0} 
    \State {return currentnode, length of closedlist, totalHeuristic  // Return the goal node and the number of nodes expanded}
    \EndIf


    \For {move in ["up", "down", "left", "right"]}
            \State successorstate = copy of currentnode.state
            
            \State cannotmove = currentnode.state.checkcanmove()
            
            \If {move in cannotmove:}
            \State continue
            \EndIf
            \If {move is "up":}
            \State successorstate.moveUp()
            \EndIf
            \If {move is "down":}
            \State successorstate.moveDown()
            \EndIf
            \If {move is "left":}
            \State successorstate.moveLeft()
            \EndIf
            \If {move is "right":}
            \State successorstate.moveRight()
            \EndIf

            \State cost = currentnode.cost + 1  // Assume uniform cost for each move
            \State heuristicTic = time.perfcounter()
            \If { funType is "other":}
            \State heuristic = successorstate.otherHeuristic()
           
            \Else 
            \State heuristic = successorstate.manhdist()
            \EndIf
            \State heuristicToc = time.perfcounter()
            \State totalHeuristic += heuristicToc - heuristicTic
            
            \State successornode = Node(successorstate, cost, heuristic, currentnode)
            \If {successornode not in closedlist:}  // This would prefer a better equality
            \State add successornode to openlist
            \EndIf

            \EndFor

            \State {return None}

   
   
   
  \label{alg:A*}
\end{algorithm}


\subsection{Recursive Best-First Search (RBFS)}
Recursive Best-First Search (RBFS) operates by maintaining an f-limit variable, tracking the f-value of the best alternative path from any ancestor node to the current node. This f-limit guides the algorithm in determining which subtree of the problem tree to explore, balancing between the current path and the best alternative path. RBFS dynamically updates the f-values of nodes during recursion unwinding to ensure search functionality, thereby allowing consideration of forgotten subtrees in future exploration.

RBFS offers the advantage of requiring less memory compared to A* search, as it utilizes linear space. Unlike A*, which stores all explored nodes, RBFS only retains "relevant" nodes in memory. However, RBFS may expand more nodes than A* due to redundancy. Since RBFS doesn't store all explored nodes, it can potentially revisit and re-expand the same nodes, leading to increased computation time.
\begin{algorithm}
   
  \If {node.state isgoal() }
  \State return node, flimit
        \EndIf
        \State successors = []
        \For {move in ["up", "down", "left", "right"]}
    \If {move is not in node.state.checkcanmove()  }
        \State {successorstate = copy of node.state}
            \State {performmove(move, successorstate) } // Execute the move on the state
            \State {cost = node.cost + 1}
            \State  {heuristic = calculateheuristic(successorstate) } // Calculate heuristic value for the successor state
            \State  {successornode = create Node with successorstate, cost, heuristic, and parent node}
            \State  {add successornode to successors list}
            \EndIf
            \EndFor
            \If {successors is empty }
            \State {return None, infinity}
        \EndIf

    \While {true  }
    \State {sort successors by fscore}
        \State {best = first node in successors}
        \If { best.fscore > flimit }
        \State {return None, best.fscore}
            \EndIf
            \State {alternative = second node's fscore if successors has more than one node else infinity}
        \State {result, best.fscore = RBFS(best, min(flimit, alternative))}
        \If { result is not None }
        \State {return result, best.fscore}
            \EndIf
            \EndWhile
  \label{alg:RBFS}
\end{algorithm}

\section{Experimental setup}

\section{Results}



\section{Discussion}
% Answer the remaining questions not answered in earlier sections
1. Is there a clear preference ordering among the heuristics you tested considering the number of nodes searched and the total CPU time taken to solve the problems for the two algorithms?

2. Can a small sacrifice in optimality give a large reduction in the number of nodes expanded? What about CPU time?

3. Is the time spent on evaluating the heuristic a significant fraction of the total problem-solving time for any heuristic and algorithm you tested?

4. How did you come up with your heuristic evaluation function?
We looked to the literature for suggestions. 

5. How do the two algorithms compare in the amount of search involved and the cpu-time?

\end{document}