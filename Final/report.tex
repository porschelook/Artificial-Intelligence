\documentclass{article}


% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2023


% ready for submission
\usepackage[preprint]{neurips_2023}


% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
%     \usepackage[preprint]{neurips_2023}


% to compile a camera-ready version, add the [final] option, e.g.:
%     \usepackage[final]{neurips_2023}


% to avoid loading the natbib package, add option nonatbib:
%    \usepackage[nonatbib]{neurips_2023}


\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{amsmath,amssymb}
\usepackage{listings,graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\title{Report for Planning a Path for a Vacuum Cleaner Agent in a Dynamic Environment}


% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to LaTeX to determine where to break the
% lines. Using \AND forces a line break at that point. So, if LaTeX puts 3 of 4
% authors names on the first line, and the last on the second line, try using
% \AND instead of \And before the third author name.


\author{%
  Matthew Callahan\\
  \And
  Suphalerk Lortaraprasert
  % examples of more authors
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \AND
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
  % \And
  % Coauthor \\
  % Affiliation \\
  % Address \\
  % \texttt{email} \\
}


\begin{document}


\maketitle


\begin{abstract}
  In this project, we present an architecture that produces a plan to navigate and clean a room of arbitrary size that has the potential for random walls in it. To do so we implemented iterative deepening and/or search. Due to our underestimation of the complexity of setting up an enviornment to handle belief states, we were unable to implement as thurough a comparison as desired.

  
\end{abstract}

\section{Introduction}

In this project, the focus lies on simulating an efficient path for a vacuum cleaning robot within dynamic environments. The diversity of real-world rooms and their varying layouts renders fixed paths impractical for universal application. Thus, our aim is to develop a solution that adapts to changing environments, ensuring optimal cleaning efficiency regardless of room type or layout. This simulation endeavors to explore and implement strategies that enable the robot to navigate dynamically and effectively, enhancing its utility in real-world scenarios.

We note that even on a $3\times 3$ board, there are at least $2^9$ possible belief states. This means that producing a complete plan is not feasible for reasonable problems in reasonable time, and that some relatively computationally efficient method is required. We implemented iterative deepening and/or search to solve this problem and thus only produce a plan for states it could reasonably expect to visit.

\section{Agent Descriptions}
The available actions of the agent are to clean the square it is on, to move forward one square, to turn left (counter clockwise) $90^\circ$, and to turn right (clockwise) $90^\circ$. The goal of the agent was to arive at a state where it knew that every cell in the room was clean. 

The agents have the ability to detect whether the square they are on are clean or dirty with 100\% reliability, as well as the state of a variable number of cells in front of them. This includes whether the cell they see is a wall.


We initially intended to design an agent that would produce a straight-line path and would therefore find a path to each cell and clean it, a version of the traveling salesman problem. However, due to poor project managment we were unable to implement this setup. We also intended to use AO* on belief states, but have instead implemented AO* on a fully observable setting, where we use AO* to find the optimal route of an agent with perfect knowledge.

Our version of And/Or search starts with an and step because it has to resolve any of the possible states it could begin in depending on which cells it could observe from its starting point, which it won't know until it begins executing its plan. The full algorithm in psuedocode is presented in Algorithm~\ref{alg:IDAO}. 
\begin{algorithm}[h]
  \caption{Iterative Deepening And/Or search as used in our project}
  \begin{algorithmic}[1]
    \State function And-Or-Search
    \For {limit$=1\ldots n$}
      \State plan=AndSearch(initialStates, emptyPlan, emptyPath, limit )
      \If {plan is not failure}
        \State return plan
      \EndIf
    \EndFor
    \State
    \State AndSearch(states, plan,path,limit)
    \If {depthlim<0}
      \State return failure
    \EndIf
    \For {state$_i$ in states}
     \State plan$_i$ = OrSearch(state$_i$, plan, path,limit-1)
      \If {plan$_i$ is failure}
        \State return failure
      \EndIf
      \State Merge plans
    \EndFor
    \State Return merged plan
    \State
    \State OrSearch(state,plan,path,limit)
    \If {DetectCycle}
      \State return failure
    \EndIf
    \If {In Goal State}
      \State mark plan complete and return
    \EndIf
    \For {each action}
      \State plan = AndSearch(states resulting from action, plan, path, limit)
      \If {plan is not failure}
        \State return plan
      \EndIf
    \EndFor
    \State return failure
  \end{algorithmic}
  \label{alg:IDAO}
\end{algorithm}

\section{Environment setup}

In our experimental setup, we categorize environments into three types: NOWALL, FIXWALL, and RANDOMWALL.

\subsection{NOWALL Environment:} This type of environment is characterized by open spaces without any fixed obstacles or walls. It represents scenarios where the robotic vacuum cleaner has unrestricted movement and can navigate freely across the entire area.

\subsection{FIXWALL Environment:} In contrast to NOWALL environments, FIXWALL environments include fixed obstacles or walls that create defined pathways and rooms within the space. This setup simulates typical indoor environments where rooms are separated by walls and furniture, influencing the robot's path planning and navigation strategy.

\subsection{RANDOMWALL Environment:} This environment type introduces variability by including randomly placed obstacles or walls within the space. The placement of these obstacles varies across different runs or simulations, mimicking dynamic and unpredictable real-world environments. This setup challenges the robot's ability to adapt its cleaning route dynamically in response to changing environmental conditions.


Each environment type serves a specific purpose in our experiments: NOWALL for testing unrestricted navigation scenarios, FIXWALL for evaluating path planning efficiency in structured environments, and RANDOMWALL for assessing adaptability and robustness in unpredictable settings. By systematically testing our robotic vacuum cleaner in these varied environments, we aim to develop and refine intelligent algorithms that optimize cleaning routes and enhance overall performance across diverse real-world conditions.

\section{Experimental setup}
The agent starts at the bottom left hand corner of a N by N grid facing up. 
It can advance one square in the direction it is facing, and can turn $90^\circ$ either direction during a time step. 
We will conduct our tests in three different environments: 1 .No Wall, 2. Fixed Wall and 3. Random Wall.
For each environment, we will employ the Straight Line Strategy and utilize the AO* search algorithm. Additionally, we will adjust the board size across six different dimensions: 5x5, 6x6, 7x7, 8x8, 9x9, and 10x10.

 



\section{Results}
There ended up being a bug in the way that plans were stored which meant that while the algorithm was capable of producing what we believe to be good plans, we were unable to test them. 


\section{Discussion}
We found that when proposing a project that it is best to do preliminary research about the difficulties assosiated with setup before submitting a proposal of work. In addition, we could likely have benefited from asking for specific citations when we were suggested to use AO* because a week was spent simply trying to understand how this applied to And-Or graphs while little progress was made otherwise. 
\end{document}